# Arch file targeting Linux 64-bit using the Intel tool chain
#
PERL          = perl
# use compiler to preprocess Fortran code
CPP           = $(NULL)
ACC           = $(NULL)
OFFLOAD_CC    = $(NULL)
OFFLOAD_FLAGS = $(NULL)
DFLAGS        = __NO_IPI_DRIVER __HAS_IEEE_EXCEPTIONS __DBCSR_DISABLE_WORKSHARE
#CSTD          = -std=c99
#CSTD          = -std=c11
OPTFLAGS      = $(NULL)
CFLAGS        = $(CSTD) -fPIC
CXXFLAGS      = $(NULL) -fPIC
FCFLAGS       = $(NULL) -fPIC #-parallel
LDFLAGS       = $(NULL) -fPIC
ACCFLAGS      = $(NULL)
IFLAGS        = $(NULL)
LIBS          = $(NULL)
LIBDIRNAME    = lib
OBJDIRNAME    = obj
EXTSDIR       = exts

# general debug flag
DBG_FLAG := -g
# Special characters
CHAR_HASH := \#

# Fortran Python based preprocessor
FYPP := $(wildcard $(TOOLSRC)/build_utils/fypp)

# LIBXSMM (https://github.com/hfp/libxsmm)
#LIBXSMMROOT := /path/to/libxsmm

# LIBINT: https://xconfigure.readthedocs.io/libint/
#LIBINTROOT := /path/to/libint

# PLUMED: https://xconfigure.readthedocs.io/plumed/
#PLUMEDROOT := /path/to/plumed

# LIBXC: https://xconfigure.readthedocs.io/libxc/
#LIBXCROOT := /path/to/libxc

# ELPA: https://xconfigure.readthedocs.io/elpa/
#ELPAROOT := /path/to/elpa

# calculate version number given by up to three components
version = $(shell echo "$$(( \
  $(if $(strip $1),$(word 1,$1)*10000,0) + \
  $(if $(strip $2),$2*100,$(if $(word 2,$1),$(word 2,$1)*100,0)) + \
  $(if $(strip $3),$3,$(if $(word 3,$1),$(word 3,$1),0))))")

WHICH := $(shell which which 2>/dev/null || echo "command -v")
which = $(shell $(WHICH) 2>/dev/null $(firstword $1))

SED := $(call which,gsed)
# GNU sed is desired (macOS)
ifeq (,$(SED))
  SED := $(call which,sed)
endif

prefix_iflags = $(addprefix -I,$1 $2 $3 $4 $5 $6 $7 $8 $9 ${10} ${11} ${12} ${13} ${14} ${15} ${16})
prefix_dflags = $(addprefix -D,$1 $2 $3 $4 $5 $6 $7 $8 $9 ${10} ${11} ${12} ${13} ${14} ${15} ${16})

IFX := $(call which,ifx)
ICX := $(call which,icx)
ICP := $(call which,icpx)

# Automatically pickup the environment (make -e is not required),
# or pickup the Intel Compiler (if available).
INTEL_FORCE := $(NULL)
ifeq (,$(filter-out 0,$(GNU)))
  INTEL_FORCE := $(if $(filter-out 0,$(INTEL)),$(filter 0,$(GNU)))
  XIAR := $(if $(call which,xiar),xiar,ar)
  ifeq (,$(shell echo "$${FC}"))
    ifneq (,$(filter ifx ifx2,$(notdir $(IFX))$(INTEL)))
      FC := ifx
    else ifneq (,$(filter ifort ifort1,$(notdir $(call which,ifort))$(INTEL)))
      FC := ifort
    endif
  endif
  ifeq (,$(if $(INTEL_FORCE),$(NULL),$(shell echo "$${CXX}")))
    ifneq (,$(filter icpx icpx2,$(notdir $(ICP))$(INTEL)))
      CXX := icpx
    else ifneq (,$(filter icpc icpc1,$(notdir $(call which,icpc))$(INTEL)))
      CXX := icpc
    endif
  endif
  ifeq (,$(if $(INTEL_FORCE),$(NULL),$(shell echo "$${CC}")))
    ifneq (,$(filter icx icx2,$(notdir $(ICX))$(INTEL)))
      CC := icx
    else ifneq (,$(filter icc icc1,$(notdir $(call which,icc))$(INTEL)))
      CC := icc
    endif
  endif
  GNU := 0
endif

MAKE_VERSION_OUT := $(shell $(MAKE) --version 2>/dev/null | head -n1)
CC_VERSION_OUT := $(shell $(CC) --version 2>/dev/null | head -n1)

# check if the Intel Development Tools are available
INTEL ?= $(strip $(if $(filter icc% icx% Intel%, \
  $(firstword $(CC_VERSION_OUT))),$(if $(IFX), 2, 1), 0))

ifneq (0,$(INTEL))
  CFG := intel
  GNU := 0
else
  CFG := gnu
  GNU := 1
endif

# DEFAULTS
#
DUMPAST ?= 0
SSE ?= 0
AVX ?= 0
MPI ?= 1
OMP ?= 1
DBG ?= $(DUMPAST)
CHK ?= $(DBG)
SYM ?= $(DBG)
FPE ?= 0
IPO ?= 0
VMAX ?= 0
STATIC ?= 1
DYNAMIC ?= 1
MKL_STATIC ?= $(STATIC)
MKL_DIRECT ?= 0
MKL_BITS ?= lp64
BEEP ?= 0

IMPI ?= $(if $(I_MPI_ROOT),$(MPI),0)
OMPRT ?= $(if $(filter-out 0,$(GNU)),gomp,iomp5)
#MATMUL ?= $(if $(filter-out 1,$(INTEL)),1,0)
LIBEXT ?= $(if $(filter-out 0,$(STATIC)),a,so)

# NDEBUG=0: keep all assertions active
# NDEBUG=1: apply to DBCSR (should be fine)
# NDEBUG=2: plus CP2K (regtests may fail)
NDEBUG ?= $(if $(filter-out 0,$(DBG)),0,1)

# BLAS=0: disabled even if found
# BLAS=1: use sequential variant
# BLAS=2: use OpenMP variant
BLAS ?= 2

# Intel FP-model
#FPCMODEL := fast=2
#FPCMODEL := precise
#FPFMODEL := fast=2
#FPFMODEL := source

EXTSHOME ?= $(CP2KHOME)/$(EXTSDIR)
EXTDBCSR ?= $(EXTSHOME)/dbcsr
DBCSRSRC ?= $(EXTDBCSR)/src
LEGACY ?= $(if $(wildcard $(EXTDBCSR)),0,1)
UNAME ?= $(shell uname    2>/dev/null)
MNAME ?= $(shell uname -m 2>/dev/null)

# advanced compiler flags
ifneq (0,$(INTEL))
  FPCMODEL := $(if $(strip $(FPCMODEL)),-fp-model $(FPCMODEL))
  FPFMODEL := $(if $(strip $(FPFMODEL)),-fp-model $(FPFMODEL))
  ifeq (1,$(INTEL))
  ifeq (,$(strip $(FPFMODEL)))
    FCFLAGS += -complex-limited-range
    #FCFLAGS += -fimf-domain-exclusion=1
    #FCFLAGS += -fast-transcendentals
  endif
  endif
  #FCFLAGS += -nostandard-realloc-lhs
endif

SCALAPACK ?= $(MPI)
ifneq (0,$(MPI))
  DFLAGS += __parallel $(if $(filter-out 1,$(MPI)),__MPI_VERSION=$(MPI),__MPI_VERSION=3)
  ifeq (0,$(GNU))
    ifeq (1,$(INTEL)) # fallback to next-gen in case of C/C++
      RANLIB := $(XIAR) -s
      AR  := $(XIAR) -r
      CXX := mpiicpc $(if $(call which,icpc),$(NULL),-cxx=icpx)
      CC  := mpiicc  $(if $(call which,icc),$(NULL),-cc=icx)
      FC  := mpiifort
      LD  := mpiifort
    else ifneq (,$(call which,mpiifx))
      RANLIB := ar -s
      AR  := ar -r
      CXX := mpiicpx
      CC  := mpiicx
      FC  := mpiifx
      LD  := mpiifx
    else
      RANLIB := $(XIAR) -s
      AR  := $(XIAR) -r
      CXX := mpiicpc  -cxx=icpx
      CC  := mpiicc   -cc=icx
      FC  := mpiifort -fc=ifx
      LD  := mpiifort -fc=ifx
    endif
  else # GNU
    RANLIB := gcc-ranlib
    AR  := gcc-ar -r
    CXX := mpicxx
    CC  := mpicc
    FC  := mpif90
    LD  := mpif90
  endif
else ifeq (0,$(GNU))
  ifeq (1,$(INTEL)) # fallback to next-gen in case of C/C++
    RANLIB := $(XIAR) -s
    AR  := $(XIAR) -r
    CXX := $(if $(call which,icpc),icpc,icpx)
    CC  := $(if $(call which,icc),icc,icx)
    FC  := ifort
    LD  := ifort
  else
    RANLIB := ar -s
    AR  := ar -r
    CXX := icpx
    CC  := icx
    FC  := ifx
    LD  := ifx
  endif
else # GNU
  RANLIB := gcc-ranlib
  AR  := gcc-ar -r
  CXX := g++
  CC  := gcc
  FC  := gfortran
  LD  := gfortran
endif
XCXX := $(CXX)
XCC := $(CC)
XFC := $(FC)

OCL ?= 0
CUDA ?= 0
ifeq (opencl,$(USE_ACCEL))
  OCL := 2
else ifeq (cuda,$(USE_ACCEL))
  CUDA := 1
else ifneq (,$(USE_ACCEL))
  $(info ================================================================================)
  $(info USE_ACCEL=$(USE_ACCEL) not fully supported!)
endif

ifneq (,$(filter-out 0,$(CUDA) $(OCL)))
  NVCC_FILE := $(call which,nvcc)
  NVCC := $(notdir $(NVCC_FILE))
  NVCC_PATH := $(if $(NVCC_FILE),$(realpath $(dir $(NVCC_FILE))/..))
  CUDA_FILE := $(wildcard $(NVCC_PATH)/../cuda/include/cuda.h)
  CUDA_PATH := $(if $(CUDA_FILE),$(NVCC_PATH)/../cuda,$(NVCC_PATH))
  CUDA_LDIR := $(if $(wildcard $(CUDA_PATH)/lib64),lib64,lib)
endif

# MKL_MPIRTL: intelmpi, openmpi
MKL_MPIRTL ?= $(if $(filter-out 0,$(IMPI)),intelmpi,openmpi)

# enable Intel MKL (if available)
MKL := 0
ifneq (0,$(BLAS))
ifneq (,$(filter x86_64,$(MNAME)))
  ifeq (,$(MKLROOT))
    MKL_INCFILE := $(lastword $(sort $(wildcard /opt/intel/compilers_and_libraries_*/linux/mkl/include/mkl.h)))
    ifneq (,$(MKL_INCFILE))
      MKLROOT := $(realpath $(dir $(MKL_INCFILE))/..)
    endif
  endif
  ifeq (,$(MKLROOT))
    MKL_INCFILE := $(wildcard /usr/include/mkl/mkl.h)
    ifneq (,$(MKL_INCFILE))
      MKLROOT := $(realpath $(dir $(MKL_INCFILE))/../..)
    endif
  endif
  ifneq (,$(MKLROOT))
    MKL := $(BLAS)
  endif
  ifeq (0,$(MKL))
    MKL_INCFILE := $(NULL)
    MKLROOT := $(NULL)
  endif
endif
endif

# COSMA section must appear before SCALAPACK section
ifneq (0,$(COSMA)) # incl. undefined
ifneq (0,$(MPI))
  COSMATGT := $(if $(NVCC),gpu,cpu)
  COSMAROOT := $(if $(COSMAROOT),$(COSMAROOT),$(firstword $(wildcard $(CP2KHOME)/../cosma*$(COSMATGT)/lib*/libcosma_pxgemm_cpp.*)))
  COSMAROOT := $(if $(COSMAROOT),$(COSMAROOT),$(firstword $(wildcard $(HOME)/cosma*$(COSMATGT)/lib*/libcosma_pxgemm_cpp.*)))
  COSMAROOT := $(if $(COSMAROOT),$(COSMAROOT),$(firstword $(wildcard $(CP2KHOME)/../cosma*/$(COSMATGT)/lib*/libcosma_pxgemm_cpp.*)))
  COSMAROOT := $(if $(COSMAROOT),$(COSMAROOT),$(firstword $(wildcard $(HOME)/cosma*/$(COSMATGT)/lib*/libcosma_pxgemm_cpp.*)))
  COSMAROOT := $(if $(COSMAROOT),$(COSMAROOT),$(firstword $(wildcard $(CP2KHOME)/../cosma*/lib*/libcosma_pxgemm_cpp.*)))
  COSMAROOT := $(if $(COSMAROOT),$(COSMAROOT),$(firstword $(wildcard $(HOME)/cosma*/lib*/libcosma_pxgemm_cpp.*)))
  ifneq (,$(COSMAROOT))
    COSMAROOT := $(realpath $(dir $(COSMAROOT))/..)
  endif
  ifneq (,$(COSMAROOT))
    LIBS += -L$(COSMAROOT)/lib64 -L$(COSMAROOT)/lib -lcosma -lcosma_pxgemm_cpp -lcosma_prefixed_pxgemm -lcosta_scalapack -lcosta
    DFLAGS += __COSMA
    ifneq (,$(NVCC))
      LIBS += -lTiled-MM
    endif
  endif
endif
endif

ifneq (0,$(NDEBUG))
  DFLAGS += NDEBUG
  ifneq (1,$(NDEBUG)) # CP2K and DBCSR
  else # only DBCSR
    ifeq (,$(wildcard $(CP2KHOME)/.inject.sh))
      INJECT := $(shell printf '$(CHAR_HASH)!/usr/bin/env bash\nif [ "$$4" ]; then\n\tif [ "$$(echo "$${@:4}" | $(SED) -n "/$$1/p" 2>/dev/null)" ]; then\n\t\texec $$3 $$2 "$${@:4}"\n\telif [ "$$1" ]; then\n\t\texec $$3 "$${@:4}"\n\telse\n\t\texec $$3 $$2 "$${@:4}"\n\tfi\nelse\n\texec $$3\nfi\n' >$(CP2KHOME)/.inject.sh)
    endif
    ifneq (,$(wildcard $(CP2KHOME)/.inject.sh))
      INJECT := $(shell chmod +x $(CP2KHOME)/.inject.sh)
      FC := $(CP2KHOME)/.inject.sh dbcsr_ -DNDEBUG $(FC)
    endif
  endif
else
  SYM = 1
endif

# Diagnostic message to be turned off
DIAG_DISABLE := 8290,8291,10010,10212,10411,10448,11060

CXX_VERSION_OUT := $(shell $(CXX) --version 2>/dev/null | head -n1)
CC_VERSION_OUT := $(shell $(CC) --version 2>/dev/null | head -n1)
FC_VERSION_OUT := $(shell $(FC) --version 2>/dev/null | head -n1)

REVERSION0 := [0-9][0-9]*\.[0-9][0-9]*\.*[0-9]*
REVERSION1 := s/..* \($(REVERSION0)\)[ \S]*.*/\1/
REVERSION2 := s/..* \([0-9]\{5\}[0-9]*\)[ \S]*.*/\1/

# Make C Compiler version number available
CC_VERSION := $(shell echo "$(CC_VERSION_OUT)" | $(SED) -n "$(REVERSION1)p")
ifeq (,$(CC_VERSION))
  CC_VERSION := $(shell echo "$(CC_VERSION_OUT)" | $(SED) -n "$(REVERSION2)p")
endif
CC_VERSION_NUM := $(call version, \
  $(shell echo "$(CC_VERSION)" | cut -d. -f1), \
  $(shell echo "$(CC_VERSION)" | cut -d. -f2), \
  $(shell echo "$(CC_VERSION)" | cut -d. -f3))

# Make Fortran Compiler version number available
FC_VERSION := $(shell echo "$(FC_VERSION_OUT)" | $(SED) -n "$(REVERSION1)p")
ifeq (,$(FC_VERSION))
  FC_VERSION := $(shell echo "$(FC_VERSION_OUT)" | $(SED) -n "$(REVERSION2)p")
endif
FC_VERSION_NUM := $(call version, \
  $(shell echo "$(FC_VERSION)" | cut -d. -f1), \
  $(shell echo "$(FC_VERSION)" | cut -d. -f2), \
  $(shell echo "$(FC_VERSION)" | cut -d. -f3))

# LEGACY support may depend on some VERSION_NUM
ifeq (0,$(LEGACY))
  ifneq (0,$(MPI))
    ifneq (0,$(IMPI))
      ifneq (,$(I_MPI_ROOT))
      ifneq (0,$(GNU))
        ifeq (,$(GNUVER))
          GNUVERS := $(shell echo "$(notdir \
            $(wildcard $(I_MPI_ROOT)/include/mpi/gfortran/*) \
            $(wildcard $(I_MPI_ROOT)/include/gfortran/*))" \
            | xargs -n1 | sort -t. -n -k1,1 -k2,2 -k3,3)
          GNUVINT := $(foreach GNUVER,$(GNUVERS),$(call version, \
            $(shell echo "$(GNUVER)" | cut -d. -f1), \
            $(shell echo "$(GNUVER)" | cut -d. -f2), \
            $(shell echo "$(GNUVER)" | cut -d. -f3)))
          ifneq (0,$(shell echo "$$(($(lastword $(GNUVINT))<$(FC_VERSION_NUM)))"))
            GNUVER := $(lastword $(GNUVERS))
          endif
        endif
        ifneq (,$(GNUVER))
          ifneq (,$(wildcard $(I_MPI_ROOT)/include/mpi/gfortran/$(GNUVER)))
            IFLAGS += $(I_MPI_ROOT)/include/mpi/gfortran/$(GNUVER)
          else ifneq (,$(wildcard $(I_MPI_ROOT)/include/gfortran/$(GNUVER)))
            IFLAGS += $(I_MPI_ROOT)/include/gfortran/$(GNUVER)
          endif
        endif
      endif
      endif
    else
      MPIROOT=$(abspath $(dir $(call which,$(FC)))/..)
      ifneq (,$(wildcard $(MPIROOT)/lib/*.mod))
        IFLAGS += $(MPIROOT)/lib
      endif
    endif
  endif
else # legacy
  DFLAGS += __HAS_ISO_C_BINDING __HAS_NO_MPI_MOD
  ifneq (0,$(OMP))
  ifeq (0,$(GNU))
    FCFLAGS += -threads
    LDFLAGS += -threads
  endif
  endif
endif

MIC ?= 0
CPUINFO := $(wildcard /proc/cpuinfo)
ifeq (0,$(GNU)) # Intel
  ifeq (0,$(INTEL))
    $(info ================================================================================)
    $(info This ARCH file relies on Intel Compiler and Libraries. Please try the following:)
    $(info $$ source /opt/intel/oneapi/setvars.sh)
    $(info ================================================================================)
    $(error Intel Development Tools not found!)
  endif
  ifneq (0,$(shell echo "$$((2 > $(DBG)))"))
    ifeq (1,$(AVX))
      TARGET := -xAVX
      TGT := snb
    else ifeq (2,$(AVX))
      TARGET := -march=core-avx2
      TGT := hsw
    else ifeq (3,$(AVX))
      ifeq (,$(MIC))
        TARGET := -xCOMMON-AVX512
        TGT := hsw
      else ifneq (0,$(MIC))
        TARGET := -xMIC-AVX512
        TGT := knl
      else
        TARGET := -xCORE-AVX512
        ifeq (1,$(INTEL))
        ifneq (0,$(VMAX))
          TARGET += -qopt-zmm-usage=$(if $(filter-out -%,$(VMAX)),high,low)
        endif
        endif
        TGT := skx
      endif
    else ifneq (0,$(SSE))
      TARGET := -xSSE3
    else
      TARGET := -xHost
      ifneq (,$(CPUINFO))
        ifneq (,$(shell grep -om1 '\bavx512vl\b' $(CPUINFO)))
          ifeq (1,$(INTEL))
          ifneq (0,$(VMAX))
            TARGET += -qopt-zmm-usage=$(if $(filter-out -%,$(VMAX)),high,low)
          endif
          endif
          TGT := skx
        else ifneq (,$(shell grep -om1 '\bavx2\b' $(CPUINFO)))
          TGT := hsw
        else ifneq (,$(shell grep -om1 '\bavx\b' $(CPUINFO)))
          TGT := snb
        endif
      endif
    endif
  endif
  ifeq (0,$(DBG))
    FCFLAGS  += $(if $(filter-out 0,$(ALIGN)),-align array64byte)
    FCFLAGS  += $(FPFMODEL) $(FPFLAGS)
    CFLAGS   += $(FPCMODEL) $(FPFLAGS)
    CXXFLAGS += $(FPCMODEL) $(FPFLAGS)
    OPT ?= 2
    #OPTFLAGS += -qoverride_limits
    ifeq (0,$(MATMUL))
      OPTFLAGS += $(if $(filter-out 0 1,$(OPT)),-qopt-matmul)
    endif
    ifneq (0,$(IPO))
      IPOFLAGS += -ipo
    else ifeq (0,$(IPO))
      LDFLAGS += -no-ipo
    endif
  else # debug
    ifeq (1,$(INTEL))
      CXXFLAGS += -debug
      FCFLAGS  += -debug
      CFLAGS   += -debug
    endif
    OPT ?= 0
  endif
  ifneq (0,$(CHK))
    FCFLAGS += -heap-arrays
    DFLAGS += __CHECK_DIAG
  endif
  ifneq (0,$(FPE))
    FCFLAGS += -fpe0 # debugging NaNs
  endif
  FCFLAGS += -free -fpp -fpscomp logicals
  DFLAGS += __INTEL
  ifneq (0,$(LEGACY))
    FCFLAGS += -std08
    DFLAGS += __F2008
  endif
  MKL_OMPRTL ?= intel
  MKL_FCRTL ?= intel
else # GNU GCC
  ifneq (0,$(shell echo "$$((2 > $(DBG)))"))
    ifeq (1,$(AVX))
      TARGET := -mavx
      TGT := snb
    else ifeq (2,$(AVX))
      TARGET := -march=core-avx2
      TARGET += $(if $(filter-out 0,$(VMAX)),-mprefer-vector-width=256)
      TGT := hsw
    else ifeq (3,$(AVX))
      TARGET := -mfma -mavx512f -mavx512cd
      ifneq (,$(filter-out 0,$(MIC))) # AVX512/MIC
        TARGET += -mavx512pf -mavx512er
        TARGET += $(if $(filter-out 0,$(VMAX)),-mprefer-vector-width=512)
        TGT := knl
      else # AVX512/Core
        TARGET += -mavx512dq -mavx512bw -mavx512vl
        TARGET += $(if $(filter-out 0,$(VMAX)),-mprefer-vector-width=512)
        TGT := skx
      endif
    else ifneq (0,$(SSE))
      TARGET := -mSSE3
    else
      TARGET := -march=native -mtune=native
      ifneq (,$(CPUINFO))
        ifneq (,$(shell grep -om1 '\bavx512vl\b' $(CPUINFO)))
          TARGET += $(if $(filter-out 0,$(VMAX)),-mprefer-vector-width=512)
          TGT := skx
        else ifneq (,$(shell grep -om1 '\bavx2\b' $(CPUINFO)))
          TARGET += $(if $(filter-out 0,$(VMAX)),-mprefer-vector-width=256)
          TGT := hsw
        else ifneq (,$(shell grep -om1 '\bavx\b' $(CPUINFO)))
          TGT := snb
        endif
      endif
    endif
  endif
  FCFLAGS += -ffree-form -ffree-line-length-none
  FCFLAGS += -Wno-argument-mismatch -fallow-argument-mismatch
  ifeq (0,$(DBG))
    OPTFLAGS += -funroll-loops -ftree-vectorize
    #FCFLAGS += -fstack-arrays
    ifneq (0,$(BLAS))
    ifeq (0,$(MATMUL))
      FCFLAGS += -fexternal-blas -fblas-matmul-limit=4
    endif
    endif
    ifneq (0,$(IPO))
      IPOFLAGS += -flto -Wl,-flto -Wno-lto-type-mismatch
    else
      IPOFLAGS += -fno-lto
    endif
    OPT ?= 3
  else # debug
    FCFLAGS += -fimplicit-none -fstrict-aliasing -finline-matmul-limit=0 \
      -Werror=aliasing -Werror=ampersand -Werror=c-binding-type -Werror=intrinsics-std -Werror=line-truncation -Werror=tabs \
      -Werror=target-lifetime -Werror=underflow -Werror=unused-but-set-variable -Werror=conversion -Werror=unused-variable \
      -Werror=zerotrip -Wintrinsic-shadow #-Warray-temporaries
    ifneq (1,$(DBG))
      ifeq (,$(NVCC))
        FCFLAGS += -Werror=uninitialized -Werror=unused-dummy-argument -Wno-maybe-uninitialized
      endif
      FCFLAGS += -std=f2008 #-Werror=realloc-lhs-all
    endif
    OPT ?= 0
  endif
  ifneq (0,$(CHK))
    FCFLAGS += -finit-derived -finit-real=snan -finit-integer=-42
    FCFLAGS += -fcheck=all -fbounds-check -fsanitize=leak
    DFLAGS += __CHECK_DIAG
  endif
  ifneq (0,$(FPE))
    FCFLAGS += -ffpe-trap=invalid,zero,overflow -fsignaling-nans
    CFLAGS += -fsignaling-nans
  endif
  ifneq (0,$(DUMPAST))
    FCFLAGS += -fdump-fortran-original
    FCLOGPIPE = >$(notdir $<).ast
    export LC_ALL=C
  endif
  MKL_OMPRTL ?= gnu
  MKL_FCRTL ?= gf
  INTEL ?= 0
endif

XCFG := $(if $(TGT),$(CFG)-$(TGT),$(CFG))
XCFGOMP := $(if $(filter-out 0,$(OMP)),$(XCFG)-omp,$(XCFG))

OPT1 := $(shell echo "$$((1<$(OPT)?1:$(OPT)))")
OPT2 := $(shell echo "$$((2<$(OPT)?2:$(OPT)))")

ifneq (0,$(SYM))
  ifeq (0,$(GNU)) # Intel
    ifneq (0,$(shell echo "$$((3 > $(OPT)))"))
      DFLAGS += $(if $(filter-out 0,$(LEGACY)),__USE_CP2K_TRACE)
      OPTFLAGS += -traceback
      LDFLAGS += -traceback
    endif
  else # GNU
    FCFLAGS += -fbacktrace
  endif
  OPTFLAGS += $(DBG_FLAG)
  LDFLAGS += $(DBG_FLAG)
endif

IOMPFLAG := -qopenmp
ifneq (0,$(OMP))
  OPTFLAGS += $(if $(filter-out 0,$(INTEL)),$(IOMPFLAG),-fopenmp)
endif

ifneq (0,$(DYNAMIC))
  LDFLAGS += -Wl,--export-dynamic
endif

ifeq (0,$(LEGACY))
  IFLAGS += $(CP2KHOME)/$(OBJDIRNAME)/$(ARCH)/$(ONEVERSION)/exts/dbcsr
  ELPA ?= 1
else # legacy
  ELPA ?= 201805
endif

$(info ================================================================================)
ifneq (,$(INTEL_FORCE))
  $(info Forced Intel Compiler even with CXX, CC, and FC being set!)
  $(info --------------------------------------------------------------------------------)
endif
$(info CXX: $(CXX_VERSION_OUT))
$(info CC: $(CC_VERSION_OUT))
$(info FC: $(FC_VERSION_OUT))
$(info MAKE: $(MAKE_VERSION_OUT))
$(info --------------------------------------------------------------------------------)
ifneq (0,$(MPI)) # incl. undefined
ifneq (0,$(IMPI))
  $(info I_MPI_ROOT: $(I_MPI_ROOT))
endif
endif
ifneq (0,$(MKL)) # incl. undefined
ifneq (,$(MKLROOT))
  $(info MKLROOT: $(MKLROOT))
endif
endif
ifneq (0,$(LIBXSMM)) # incl. undefined
  ifneq (,$(wildcard $(CP2KHOME)/../libxsmm/Makefile))
    LIBXSMMROOT ?= $(abspath $(CP2KHOME)/../libxsmm)
  else ifneq (,$(wildcard $(CP2KHOME)/../libxsmm-develop/Makefile))
    LIBXSMMROOT ?= $(abspath $(CP2KHOME)/../libxsmm-develop)
  else ifneq (,$(wildcard $(CP2KHOME)/../libxsmm-main/Makefile))
    LIBXSMMROOT ?= $(abspath $(CP2KHOME)/../libxsmm-main)
  else ifneq (,$(wildcard $(CP2KHOME)/../libxsmm-*/Makefile))
    LIBXSMMROOT ?= $(abspath $(dir $(lastword $(sort $(wildcard $(CP2KHOME)/../libxsmm-*/Makefile)))))
  else ifneq (,$(wildcard $(HOME)/libxsmm/Makefile))
    LIBXSMMROOT ?= $(abspath $(HOME)/libxsmm)
  else ifneq (,$(wildcard $(HOME)/libxsmm-develop/Makefile))
    LIBXSMMROOT ?= $(abspath $(HOME)/libxsmm-develop)
  else ifneq (,$(wildcard $(HOME)/libxsmm-main/Makefile))
    LIBXSMMROOT ?= $(abspath $(HOME)/libxsmm-main)
  else ifneq (,$(wildcard $(HOME)/libxsmm-*/Makefile))
    LIBXSMMROOT ?= $(abspath $(dir $(lastword $(sort $(wildcard $(HOME)/libxsmm-*/Makefile)))))
  else ifneq (,$(wildcard $(TOOLSRC)/toolchain/build/libxsmm*/Makefile))
    LIBXSMMROOT ?= $(abspath $(dir $(lastword $(sort $(wildcard $(TOOLSRC)/toolchain/build/libxsmm*/Makefile)))))
  endif
  LIBXSMMROOT := $(realpath $(LIBXSMMROOT))
  ifneq (,$(LIBXSMMROOT))
    $(info LIBXSMMROOT: $(LIBXSMMROOT))
  endif
endif
ifneq (0,$(LIBINT)) # incl. undefined
  ifneq (,$(wildcard $(LIBINT_BASEDIR)/$(XCFG)))
    LIBINTROOT ?= $(abspath $(LIBINT_BASEDIR)/$(XCFG))
  else ifneq (,$(wildcard $(CP2KHOME)/../libint/$(XCFG)))
    LIBINTROOT ?= $(abspath $(CP2KHOME)/../libint/$(XCFG))
  else ifneq (,$(wildcard $(HOME)/libint/$(XCFG)))
    LIBINTROOT ?= $(abspath $(HOME)/libint/$(XCFG))
  else ifneq (,$(wildcard $(LIBINT_BASEDIR)/$(CFG)))
    LIBINTROOT ?= $(abspath $(LIBINT_BASEDIR)/$(CFG))
  else ifneq (,$(wildcard $(CP2KHOME)/../libint/$(CFG)))
    LIBINTROOT ?= $(abspath $(CP2KHOME)/../libint/$(CFG))
  else ifneq (,$(wildcard $(HOME)/libint/$(CFG)))
    LIBINTROOT ?= $(abspath $(HOME)/libint/$(CFG))
  endif
  LIBINTROOT := $(realpath $(LIBINTROOT))
  ifneq (,$(LIBINTROOT))
    $(info LIBINTROOT: $(LIBINTROOT))
    DFLAGS += __LIBINT __MAX_CONTR=4
    IFLAGS += $(LIBINTROOT)/include
    ifneq (,$(wildcard $(LIBINTROOT)/lib64/libint2.*))
      LIBS += $(LIBINTROOT)/lib64/libint2.a
    else ifneq (,$(wildcard $(LIBINTROOT)/lib/libint2.*))
      LIBS += $(LIBINTROOT)/lib/libint2.a
    else # LIBINT1
      LIBS += $(LIBINTROOT)/lib/libderiv.a $(LIBINTROOT)/lib/libint.a
      DFLAGS += __LIBINT_MAX_AM=7 __LIBDERIV_MAX_AM1=6
    endif
  endif
endif
ifneq (0,$(PLUMED)) # incl. undefined
  ifneq (,$(wildcard $(PLUMED_BASEDIR)/$(XCFG)))
    PLUMEDROOT ?= $(abspath $(PLUMED_BASEDIR)/$(XCFG))
  else ifneq (,$(wildcard $(CP2KHOME)/../plumed/$(XCFG)))
    PLUMEDROOT ?= $(abspath $(CP2KHOME)/../plumed/$(XCFG))
  else ifneq (,$(wildcard $(HOME)/plumed/$(XCFG)))
    PLUMEDROOT ?= $(abspath $(HOME)/plumed/$(XCFG))
  else ifneq (,$(wildcard $(PLUMED_BASEDIR)/$(CFG)))
    PLUMEDROOT ?= $(abspath $(PLUMED_BASEDIR)/$(CFG))
  else ifneq (,$(wildcard $(CP2KHOME)/../plumed/$(CFG)))
    PLUMEDROOT ?= $(abspath $(CP2KHOME)/../plumed/$(CFG))
  else ifneq (,$(wildcard $(HOME)/plumed/$(CFG)))
    PLUMEDROOT ?= $(abspath $(HOME)/plumed/$(CFG))
  endif
  PLUMEDROOT := $(realpath $(PLUMEDROOT))
  ifneq (,$(PLUMEDROOT))
    $(info PLUMEDROOT: $(PLUMEDROOT))
    DFLAGS += __PLUMED2
    # avoid duplicated libraries (-ldl -lstdc++)
    LIBS += $(PLUMEDROOT)/lib/libplumed.a -lz
  endif
endif
ifneq (0,$(LIBXC)) # incl. undefined
  ifneq (,$(wildcard $(LIBXC_BASEDIR)/$(XCFG)))
    LIBXCROOT ?= $(abspath $(LIBXC_BASEDIR)/$(XCFG))
  else ifneq (,$(wildcard $(CP2KHOME)/../libxc/$(XCFG)))
    LIBXCROOT ?= $(abspath $(CP2KHOME)/../libxc/$(XCFG))
  else ifneq (,$(wildcard $(HOME)/libxc/$(XCFG)))
    LIBXCROOT ?= $(abspath $(HOME)/libxc/$(XCFG))
  else ifneq (,$(wildcard $(LIBXC_BASEDIR)/$(CFG)))
    LIBXCROOT ?= $(abspath $(LIBXC_BASEDIR)/$(CFG))
  else ifneq (,$(wildcard $(CP2KHOME)/../libxc/$(CFG)))
    LIBXCROOT ?= $(abspath $(CP2KHOME)/../libxc/$(CFG))
  else ifneq (,$(wildcard $(HOME)/libxc/$(CFG)))
    LIBXCROOT ?= $(abspath $(HOME)/libxc/$(CFG))
  endif
  LIBXCROOT := $(realpath $(LIBXCROOT))
  ifneq (,$(LIBXCROOT))
    $(info LIBXCROOT: $(LIBXCROOT))
    DFLAGS += __LIBXC
    IFLAGS += $(LIBXCROOT)/include
    ifneq (,$(wildcard $(LIBXCROOT)/lib64/libxcf03.a))
      LIBS += $(LIBXCROOT)/lib64/libxcf03.a
    else ifneq (,$(wildcard $(LIBXCROOT)/lib/libxcf03.a))
      LIBS += $(LIBXCROOT)/lib/libxcf03.a
    endif
    ifneq (,$(wildcard $(LIBXCROOT)/lib64/libxc.a))
      LIBS += $(LIBXCROOT)/lib64/libxc.a
    else ifneq (,$(wildcard $(LIBXCROOT)/lib/libxc.a))
      LIBS += $(LIBXCROOT)/lib/libxc.a
    endif
  endif
endif
ifneq (0,$(LIBGRPP)) # incl. undefined
  ifneq (,$(wildcard $(LIBGRPP_BASEDIR)/$(XCFG)))
    LIBGRPPROOT ?= $(abspath $(LIBGRPP_BASEDIR)/$(XCFG))
  else ifneq (,$(wildcard $(CP2KHOME)/../libgrpp/$(XCFG)))
    LIBGRPPROOT ?= $(abspath $(CP2KHOME)/../libgrpp/$(XCFG))
  else ifneq (,$(wildcard $(HOME)/libgrpp/$(XCFG)))
    LIBGRPPROOT ?= $(abspath $(HOME)/libgrpp/$(XCFG))
  else ifneq (,$(wildcard $(LIBGRPP_BASEDIR)/$(CFG)))
    LIBGRPPROOT ?= $(abspath $(LIBGRPP_BASEDIR)/$(CFG))
  else ifneq (,$(wildcard $(CP2KHOME)/../libgrpp/$(CFG)))
    LIBGRPPROOT ?= $(abspath $(CP2KHOME)/../libgrpp/$(CFG))
  else ifneq (,$(wildcard $(HOME)/libgrpp/$(CFG)))
    LIBGRPPROOT ?= $(abspath $(HOME)/libgrpp/$(CFG))
  endif
  LIBGRPPROOT := $(realpath $(LIBGRPPROOT))
  ifneq (,$(LIBGRPPROOT))
  ifneq (,$(wildcard $(LIBGRPPROOT)/lib/liblibgrpp.a))
    $(info LIBGRPPROOT: $(LIBGRPPROOT))
    LIBS += $(LIBGRPPROOT)/lib/liblibgrpp.a
    IFLAGS += $(LIBGRPPROOT)/include
    DFLAGS += __LIBGRPP
  endif
  endif
endif
ifneq (0,$(ELPA)) # incl. undefined
  ifneq (,$(wildcard $(ELPA_BASEDIR)/$(XCFGOMP)))
    ELPAROOT ?= $(abspath $(ELPA_BASEDIR)/$(XCFGOMP))
  else ifneq (,$(wildcard $(CP2KHOME)/../elpa/$(XCFGOMP)))
    ELPAROOT ?= $(abspath $(CP2KHOME)/../elpa/$(XCFGOMP))
  else ifneq (,$(wildcard $(HOME)/elpa/$(XCFGOMP)))
    ELPAROOT ?= $(abspath $(HOME)/elpa/$(XCFGOMP))
  else ifneq (,$(wildcard $(ELPA_BASEDIR)/$(XCFG)))
    ELPAROOT ?= $(abspath $(ELPA_BASEDIR)/$(XCFG))
  else ifneq (,$(wildcard $(CP2KHOME)/../elpa/$(XCFG)))
    ELPAROOT ?= $(abspath $(CP2KHOME)/../elpa/$(XCFG))
  else ifneq (,$(wildcard $(HOME)/elpa/$(XCFG)))
    ELPAROOT ?= $(abspath $(HOME)/elpa/$(XCFG))
  else ifneq (,$(wildcard $(ELPA_BASEDIR)/$(CFG)-omp))
    ELPAROOT ?= $(abspath $(ELPA_BASEDIR)/$(CFG)-omp)
  else ifneq (,$(wildcard $(CP2KHOME)/../elpa/$(CFG)-omp))
    ELPAROOT ?= $(abspath $(CP2KHOME)/../elpa/$(CFG)-omp)
  else ifneq (,$(wildcard $(HOME)/elpa/$(CFG)-omp))
    ELPAROOT ?= $(abspath $(HOME)/elpa/$(CFG)-omp)
  else ifneq (,$(wildcard $(ELPA_BASEDIR)/$(CFG)))
    ELPAROOT ?= $(abspath $(ELPA_BASEDIR)/$(CFG))
  else ifneq (,$(wildcard $(CP2KHOME)/../elpa/$(CFG)))
    ELPAROOT ?= $(abspath $(CP2KHOME)/../elpa/$(CFG))
  else ifneq (,$(wildcard $(HOME)/elpa/$(CFG)))
    ELPAROOT ?= $(abspath $(HOME)/elpa/$(CFG))
  endif
  ifneq (,$(ELPAROOT))
    $(info ELPAROOT: $(ELPAROOT))
  endif
endif
ifneq (0,$(SLATE)) # incl. undefined
  ifneq (,$(wildcard $(SLATE_BASEDIR)/$(XCFG)))
    SLATEROOT ?= $(abspath $(SLATE_BASEDIR)/$(XCFG))
  else ifneq (,$(wildcard $(CP2KHOME)/../slate/$(XCFG)))
    SLATEROOT ?= $(abspath $(CP2KHOME)/../slate/$(XCFG))
  else ifneq (,$(wildcard $(HOME)/slate/$(XCFG)))
    SLATEROOT ?= $(abspath $(HOME)/slate/$(XCFG))
  else ifneq (,$(wildcard $(SLATE_BASEDIR)/$(CFG)))
    SLATEROOT ?= $(abspath $(SLATE_BASEDIR)/$(CFG))
  else ifneq (,$(wildcard $(CP2KHOME)/../slate/$(CFG)))
    SLATEROOT ?= $(abspath $(CP2KHOME)/../slate/$(CFG))
  else ifneq (,$(wildcard $(HOME)/slate/$(CFG)))
    SLATEROOT ?= $(abspath $(HOME)/slate/$(CFG))
  endif
  SLATEROOT := $(realpath $(SLATEROOT))
  ifneq (,$(SLATEROOT))
    $(info SLATEROOT: $(SLATEROOT))
    SLATE_LDIR := $(if $(wildcard $(SLATEROOT)/lib64),lib64,lib)
    SCALAPACK_ADDON += -L$(SLATEROOT)/$(SLATE_LDIR) -lslate_scalapack_api
    SCALAPACK_ADDON += -Wl,-rpath,$(SLATEROOT)/$(SLATE_LDIR)
    ifneq (,$(ICX)) # if Slate was eventually built with Intel Compiler
      SCALAPACK_ADDON += -Wl,--as-needed
      ifneq (2,$(INTEL))
        SCALAPACK_ADDON += -lsycl -lur_loader -lomptarget
        ifneq (0,$(GNU))
          SCALAPACK_ADDON += -lsvml -lirc
          OMPRT = iomp5
        endif
      endif
      SCALAPACK_ADDON += -Wl,--no-as-needed
    endif
  endif
endif
ifneq (0,$(COSMA)) # incl. undefined
ifneq (,$(COSMAROOT))
  $(info COSMAROOT: $(COSMAROOT))
endif
endif
$(info ================================================================================)

ifneq (0,$(ELPA))
ifneq (,$(ELPAROOT))
  ELPAINCDIR := $(dir $(firstword $(wildcard $(ELPAROOT)/include/*/elpa/elpa_*constants.h)))
  ELPALIBDIR := $(firstword $(wildcard $(ELPAROOT)/lib64 $(wildcard $(ELPAROOT)/lib)))
  ifneq (,$(ELPAINCDIR))
  ifneq (,$(ELPALIBDIR))
    ELPALIB := $(patsubst $(ELPALIBDIR)/lib%.$(LIBEXT),%,$(firstword $(wildcard $(ELPALIBDIR)/libelpa*.$(LIBEXT))))
  endif
  endif
  ifneq (,$(ELPALIB))
    IFLAGS += $(ELPAINCDIR) $(ELPAINCDIR)/../modules
    DFLAGS += __ELPA=$(ELPA)
    ifeq (0,$(STATIC))
      LIBS += -L$(ELPALIBDIR) -Wl,-rpath,$(ELPALIBDIR) -l$(ELPALIB)
    else
      LIBS += $(ELPALIBDIR)/lib$(ELPALIB).a
    endif
    ifneq (0,$(CUDA))
      DFLAGS += __ELPA_NVIDIA_GPU
    else ifneq (,$(filter-out 0 1 2,$(OCL))) # 3 <= OCL
      ifneq (,$(ICX)) # if ELPA was eventually built with Intel Compiler
        INTEL_LDIR := $(realpath $(dir $(ICX))/../lib)
        ifneq (,$(INTEL_LDIR))
          LIBS += -L$(INTEL_LDIR) -Wl,-rpath,$(INTEL_LDIR)
        endif
        LIBS += -Wl,--as-needed
        LIBS += -lmkl_sycl
        ifneq (2,$(INTEL))
          LIBS += -lsycl
          ifneq (0,$(GNU))
            LIBS += -lsvml
            OMPRT = iomp5
          endif
        else
          LDFLAGS += -fsycl
        endif
        LIBS += -Wl,--no-as-needed
        DFLAGS += __ELPA_INTEL_GPU
        MKL_FCRTL = intel
        #MKL_BITS = ilp64
      endif
    endif
  endif
endif
endif

ifneq (,$(LIBXSMMROOT))
  # 1: SMMs, 2: 1+UnreleasedFeat, 3: 2+AllGEMM
  LIBXSMM ?= 1
  ifneq (0,$(LIBXSMM))
    LIBXSMM_DSTDIR := $(CP2KHOME)/$(LIBDIRNAME)/$(ARCH)/$(ONEVERSION)/libxsmm
    DFLAGS += __LIBXSMM=$(LIBXSMM)
    ifneq (0,$(GNU))
      ifneq (0,$(DBG))
      # suppress "Fortran runtime warning:"
        LDFLAGS += -Wl,--wrap=_gfortran_runtime_warning_at
      endif
      ifeq (,$(filter _0_ __,_$(SIMD)_)) # force-enable with SIMD=1
      # GNU: https://github.com/cp2k/dbcsr/issues/217
        DFLAGS += _OPENMP_SIMD
        OPTFLAGS += -fopenmp-simd
      endif
    else
      DFLAGS += _OPENMP_SIMD
      OPTFLAGS += $(IOMPFLAG)-simd
    endif
    IFLAGS += $(LIBXSMM_DSTDIR)/include

    # link libxsmmext (needed at least in case of WRAP)
    ifneq (0,$(STATIC))
      LIBS += $(LIBXSMM_DSTDIR)/lib/libxsmmf.a
      LIBS += $(LIBXSMM_DSTDIR)/lib/libxsmmext.a
      LIBS += $(LIBXSMM_DSTDIR)/lib/libxsmm.a
    else
      LIBS += -L$(LIBXSMM_DSTDIR)/lib -Wl,-rpath,$(LIBXSMM_DSTDIR)/lib
      LIBS += -lxsmmf -lxsmmext -lxsmm
    endif

    # account for OpenMP-enabled libxsmmext routines
    ifeq (0,$(OMP))
      DFLAGS += DBCSR_LIBXSMM_GEMM_BATCH=libxsmm_gemm_batch_omp
    endif
    # enable additional use cases for LIBXSMM
    ifneq (0,$(shell echo "$$((1 < $(LIBXSMM)))"))
      BIGVERNUM := echo "99" > version.txt
      # substitute all GEMM calls with LIBXSMM
      WRAP ?= $(shell echo "$$(((2<$(LIBXSMM))*($(LIBXSMM)-2)))")
      ifneq (0,$(STATIC))
      ifneq (0,$(WRAP))
        ifneq (0,$(shell echo "$$((2<$(WRAP)))"))
          LDFLAGS += -Wl,--wrap=dgemm_,--wrap=sgemm_,--wrap=dgemv_,--wrap=sgemv_
          ifneq (0,$(shell echo "$$((3<$(WRAP)))"))
            LIBS += $(LIBXSMM_DSTDIR)/lib/libxsmmnoblas.a
          endif
        else
          LDFLAGS += -Wl,--wrap=dgemm_,--wrap=sgemm_
        endif
      endif
      endif
    else
      BIGVERNUM := rm -f version.txt
    endif
    WRAP ?= 0
    JIT ?= 1
    ifneq (0,$(shell echo "$$((0>=$(JIT)))"))
      LIBXSMM_MNK := "23, 6, 14 16 29, 14 32 29, 5 32 13 24 26, 9 32 22, 64, 78, 16 29 55, 32 29 55, 12, 4 5 7 9 13 25 26 28 32 45"
    endif
-include libxsmm
.PHONY: libxsmm
libxsmm:
	@$(BIGVERNUM)
	@mkdir -p $(LIBXSMM_DSTDIR)
	@$(MAKE) -C $(LIBXSMM_DSTDIR) -f "$(LIBXSMMROOT)/Makefile" --no-print-directory \
		CXX="$(XCXX)" CC="$(XCC)" FC="$(XFC)" "AR=$(firstword $(AR))" WERROR=0 \
		STATIC=$(STATIC) JIT=$(JIT) SYM=$(SYM) DBG=$(DBG) OPT=$(OPT) IPO=0 INIT=0 MALLOC=0 WRAP=$(WRAP) \
		MNK=$(LIBXSMM_MNK) M=$(LIBXSMM_M) N=$(LIBXSMM_N) K=$(LIBXSMM_K) PRECISION=2 VTUNE=0 \
		CTARGET="$(TARGET)" SSE=$(SSE) AVX=$(AVX) MIC=$(MIC) INTEL=$(INTEL) GNU=$(GNU) \
		$(if $(filter-out 0,$(shell echo "$$((3<$(WRAP)))")),BLAS=0) >&2
    ifneq (0,$(EXTSPACKAGES))
$(EXTSPACKAGES): libxsmm
    endif
  endif
endif

ifneq (0,$(SCALAPACK))
ifneq (0,$(MPI))
  DFLAGS += __SCALAPACK
  ifneq (0,$(LEGACY))
    DFLAGS += __BLACS
  endif
  ifeq (0,$(shell echo $(SCALAPACK) | grep -q "^-*[0-9]\+$$"; echo $$?)) # number
    ifneq (-1,$(SCALAPACK))
    ifneq (1,$(SCALAPACK))
      DFLAGS += __SCALAPACK$(SCALAPACK)
    endif
    endif
  endif
  ifneq (,$(MKLROOT)) # link as part of MKL even for non-MKL ScaLAPACK
    SCALAPACKDIR := $(MKLROOT)/lib/intel64
    SCALAPACKLIB := mkl_scalapack_$(MKL_BITS)
  else # not via MKL
    #SCALAPACKLIB := $(if $(filter-out 0,$(IMPI)),scalapack,scalapack-openmpi)
    SCALAPACKLIB := scalapack
    ifneq (,$(SCALAPACKDIR))
      LIBS += -L$(SCALAPACKDIR)
    endif
    ifneq (,$(SCALAPACKLIB))
      LIBS += -l$(SCALAPACKLIB)
    endif
  endif
  ifneq (,$(SCALAPACK_ADDON))
    LIBS += $(SCALAPACK_ADDON)
    MKL_STATIC = 0
  endif
endif
endif

ifneq (0,$(MKL))
  DFLAGS += __MKL __FFTW3
  DFLAGS += $(if $(filter 1,$(MKL_DIRECT)),MKL_DIRECT_CALL_SEQ)
  ifeq (,$(MKL_INCFILE))
    IFLAGS += $(MKLROOT)/include
    ifneq (,$(wildcard $(MKLROOT)/include/fftw))
      IFLAGS += $(MKLROOT)/include/fftw
    endif
  else
    IFLAGS += $(dir $(MKL_INCFILE))
    ifneq (,$(wildcard $(dir $(MKL_INCFILE))/fftw))
      IFLAGS += $(dir $(MKL_INCFILE))/fftw
    endif
  endif
  ifeq (1,$(MKL)) # sequential
    MKL_THREADS := sequential
  else ifneq (0,$(MKL)) # multi-threaded
    MKL_THREADS := $(MKL_OMPRTL)_thread
  endif
  ifeq (ilp64,$(MKL_BITS))
    DFLAGS += MKL_ILP64
  endif
  ifeq (0,$(MKL_STATIC))
    LIBS += -L$(MKLROOT)/lib/intel64 -Wl,-rpath,$(MKLROOT)/lib/intel64
    ifneq (0,$(MPI))
      LIBS += -l$(SCALAPACKLIB) -lmkl_$(MKL_FCRTL)_$(MKL_BITS) -lmkl_core -lmkl_$(MKL_THREADS) -lmkl_blacs_$(MKL_MPIRTL)_$(MKL_BITS)
    else
      LIBS += -lmkl_$(MKL_FCRTL)_$(MKL_BITS) -lmkl_core -lmkl_$(MKL_THREADS)
    endif
  else # static
    ifneq (0,$(MPI))
      LIBS += \
        -Wl,--start-group \
          $(SCALAPACKDIR)/lib$(SCALAPACKLIB).a \
          $(MKLROOT)/lib/intel64/libmkl_$(MKL_FCRTL)_$(MKL_BITS).a \
          $(MKLROOT)/lib/intel64/libmkl_core.a \
          $(MKLROOT)/lib/intel64/libmkl_$(MKL_THREADS).a \
          $(MKLROOT)/lib/intel64/libmkl_blacs_$(MKL_MPIRTL)_$(MKL_BITS).a \
        -Wl,--end-group
    else
      LIBS += \
        -Wl,--start-group \
          $(MKLROOT)/lib/intel64/libmkl_$(MKL_FCRTL)_$(MKL_BITS).a \
          $(MKLROOT)/lib/intel64/libmkl_core.a \
          $(MKLROOT)/lib/intel64/libmkl_$(MKL_THREADS).a \
        -Wl,--end-group
    endif
  endif
  LIBS += -Wl,--as-needed
  LIBS += -lpthread -ldl $(if $(filter-out 0,$(INTEL)),-limf,-lm)
  LIBS += -Wl,--no-as-needed
else ifneq (0,$(BLAS)) # generic
  ifneq (,$(AOCL_ROOT))
    ifeq (0,$(STATIC)) # shared
      LIBS += -L$(AOCL_ROOT)/lib -Wl,-rpath,$(AOCL_ROOT)/lib
      ifeq (1,$(BLAS)) # sequential
        LIBS += -lblis
      else # multi-threaded
        LIBS += -lblis-mt
      endif
    else # static
      ifeq (1,$(BLAS)) # sequential
        LIBS += $(AOCL_ROOT)/lib/libblis.so
      else # multi-threaded
        LIBS += $(AOCL_ROOT)/lib/libblis-mt.so
      endif
    endif
  else ifneq (1,$(BLAS))
    LIBS += -lopenblas
  else
    LIBS += -lblas
  endif
endif

# Define __INTEL_COMPILER in case of external preprocessing because some source (pw/fft/fftw3_lib.F)
# toggles code using this symbol, but of course the cpp preprocessor is not defining this symbol.
ifneq (,$(CPP))
  CPPFLAGS += -C $(call prefix_iflags,$(IFLAGS)) $(call prefix_dflags,$(DFLAGS) __INTEL_COMPILER) -P -traditional
endif

# finalize flags common to CXX, CC, and FC
OPTFLAGS := $(TARGET) $(OPTFLAGS) -O$(OPT)

ifneq (,$(filter-out 0,$(OCL) $(CUDA) $(HIP)))
  DFLAGS += __ACC __DBCSR_ACC
  ifneq (0,$(OCL))
    ifneq (1,$(OCL))
      OPENCL_DBM_CMN := $(wildcard $(DBCSRSRC)/acc/opencl/common/*.h)
      OPENCL_DBM_SRC := $(CP2KHOME)/src/dbm/dbm_multiply_opencl.cl
      OPENCL_DBM_GEN := $(DBCSRSRC)/acc/opencl/acc_opencl.sh
$(OPENCL_DBM_SRC).h: $(OPENCL_DBM_GEN) $(OPENCL_DBM_SRC) $(OPENCL_DBM_CMN)
	$(OPENCL_DBM_GEN) -b 6 -p "" $(OPENCL_DBM_SRC) $@
dbm_multiply_opencl.o: dbm_multiply_opencl.c $(ALL_HEADERS) $(OPENCL_DBM_SRC).h
	$(CC) -c $(CFLAGS) $<
      DFLAGS += __OFFLOAD_OPENCL
      # TODO: implement support or missing features for GRID and PW
      DFLAGS += __NO_OFFLOAD_GRID __NO_OFFLOAD_PW
      IFLAGS += $(EXTDBCSR)
    endif
    ifeq (Darwin,$(UNAME))
      LIBS += -framework OpenCL
    else
      ifneq (,$(CUDA_PATH))
        IFLAGS += $(CUDA_PATH)/include
        #LIBS += -L$(CUDA_PATH)/$(CUDA_LDIR)
      else ifneq (,$(wildcard $(OPENCL_ROOT)/include/CL/cl.h))
        OPENCL_LDIR := $(if $(wildcard $(OPENCL_ROOT)/lib64),lib64,lib)
        LIBS += -L$(OPENCL_ROOT)/$(OPENCL_LDIR)
        IFLAGS += $(OPENCL_ROOT)/include
      else ifneq (,$(ICX))
        OPENCL_ROOT := $(abspath $(dir $(ICX))/..)
        ifneq (,$(wildcard $(OPENCL_ROOT)/include/sycl/CL/cl.h))
          OPENCL_LDIR := $(if $(wildcard $(OPENCL_ROOT)/lib64),lib64,lib)
          LIBS += -L$(OPENCL_ROOT)/$(OPENCL_LDIR) -L$(OPENCL_ROOT)/compiler/lib/intel64 -lintlc
          IFLAGS += $(OPENCL_ROOT)/include/sycl
        endif
      endif
      OCL_ICD_LOADER := $(firstword $(wildcard /usr/lib/*/libOpenCL.so.*))
      LIBS += $(if $(OCL_ICD_LOADER),$(OCL_ICD_LOADER),-l:libOpenCL.so.1)
    endif
    ACCFLAGS += $(CFLAGS)
    USE_ACCEL := opencl
    ACC := $(CC)
  else ifneq (0,$(CUDA))
    ifneq (,$(CUDA_PATH))
      ifneq (undefined,$(origin GPUVER))
        ifneq (0,$(SYM))
          ACCFLAGS += $(DBG_FLAG)
        endif
        IFLAGS += $(CUDA_PATH)/include
        DFLAGS += __CUDA __OFFLOAD_CUDA __GRID_CUDA __DBM_CUDA __PW_GPU __PW_CUDA
        LIBS += -L$(CUDA_PATH)/$(CUDA_LDIR) -lcudart -lcublas -lcufft -lnvrtc -lcuda
        # consider omitting opt-level entirely due to extreme compilation time even when flag targets only the host compiler
        ACCFLAGS := -O$(OPT) $(addprefix -Xcompiler $(NULL),$(filter-out $(DBG_FLAG) -O$(OPT) -Wl%,$(OPTFLAGS))) $(call prefix_dflags,$(DFLAGS))
        NVCFLAGS := $(ACCFLAGS)
        NVFLAGS := $(ACCFLAGS)
        USE_ACCEL := cuda
        ACC := $(NVCC)
        IPO := 0
      else
        $(info ===================)
        $(info GPUVER not defined!)
        $(info ===================)
        $(error GPUVER)
      endif
    else
      $(info ===============)
      $(info NVCC not found!)
      $(info ===============)
      $(error NVCC)
    endif
  else ifneq (0,$(HIP))
    ifneq (undefined,$(origin GPUVER))
      DFLAGS += __CUDA __OFFLOAD_HIP
      USE_ACCEL := hip
      IPO := 0
    else
      $(info ===================)
      $(info GPUVER not defined!)
      $(info ===================)
      $(error GPUVER)
    endif
  endif
else # ACC off
  ifeq (0,$(GNU))
  ifneq (0,$(LEGACY))
    OPTFLAGS += -qno-offload
  endif
  endif
endif

CXXFLAGS  += $(OPTFLAGS) $(IPOFLAGS) $(call prefix_dflags,$(DFLAGS)) $(call prefix_iflags,$(IFLAGS)) #-std=c++0x
CFLAGS    += $(OPTFLAGS) $(call prefix_dflags,$(DFLAGS)) $(call prefix_iflags,$(IFLAGS))
FCFLAGS   += $(OPTFLAGS) $(IPOFLAGS) $(call prefix_dflags,$(DFLAGS)) $(call prefix_iflags,$(IFLAGS))
# apply opt-level at link-line to avoid Intel Compiler remark #10440
LDFLAGS   += -O$(OPT) $(IPOFLAGS) #-static-intel -static-libgcc -static-libstdc++

ifeq (0,$(GNU))
ifneq (0,$(INTEL))
  # workaround for certain bits introduced by GCC 7.0
  ifneq (0,$(shell echo "$$((180002 >= $(CC_VERSION_NUM) && 0 != $(CC_VERSION_NUM)))"))
    DFLAGS +=_Float128=__float128
  endif
  CXXFLAGS  += -fno-alias -ansi-alias -diag-disable $(DIAG_DISABLE)
  CFLAGS    += -fno-alias -ansi-alias -diag-disable $(DIAG_DISABLE)
  FCFLAGS   += -diag-disable $(DIAG_DISABLE)
  LDFLAGS   += -diag-disable $(DIAG_DISABLE)
  # consider -nofor_main for legacy compiler
  LDFLAGS_C += -nofor-main
endif
endif

# Collect all paths in LD_LIBRARY_PATH and LD_LIBRARY_PATH/stubs, and append to LIBS
LD_LIBRARY_PATH := $(wildcard $(subst :, ,$(LD_LIBRARY_PATH)))
LD_LIBSTUB_PATH := $(wildcard $(patsubst %,%/stubs,$(LD_LIBRARY_PATH)))
#LD_INCLUDE_PATH := $(wildcard $(patsubst %,$(abspath %/../include),$(LD_LIBRARY_PATH)))
LIBPATHS := $(foreach DIR,$(LD_LIBRARY_PATH),$(if $(filter -L$(DIR),$(LIBS)),$(NULL),-L$(DIR)))
LIBSTUBS := $(foreach DIR,$(LD_LIBSTUB_PATH),$(if $(filter -L$(DIR),$(LIBS)),$(NULL),-L$(DIR)))
LIBS += $(LIBPATHS) $(LIBSTUBS) -Wl,--as-needed -lstdc++ -l$(OMPRT) -Wl,--no-as-needed
#IFLAGS += $(INCPATHS)

cleanup = $(foreach FLAG,$1,$(FLAG))
LDFLAGS := $(filter-out -ipo -ipo-separate,$(call cleanup,$(LDFLAGS)))
CXXFLAGS := $(call cleanup,$(CXXFLAGS))
FCFLAGS := $(call cleanup,$(FCFLAGS))
CFLAGS := $(call cleanup,$(CFLAGS))
DFLAGS := $(call cleanup,$(DFLAGS))
IFLAGS := $(call cleanup,$(IFLAGS))

# apply ACC settings for CP2K/GRID code
OFFLOAD_TARGET := $(USE_ACCEL)
OFFLOAD_FLAGS := $(ACCFLAGS)
OFFLOAD_CC := $(ACC)

ifneq (,$(CSTD))
dbm_miniapp.o: dbm_miniapp.c $(ALL_HEADERS)
	$(CC) -c $(filter-out $(CSTD),$(CFLAGS)) $<
endif

ifneq (0,$(NDEBUG))
environment.o: environment.F
	$(eval MAKE_FYPP := $(if $(FYPP),$(FYPP) $(FYPPFLAGS) $< $*.F90))
	$(MAKE_FYPP)
	$(FC) -c $(filter-out -DNDEBUG,$(FCFLAGS)) -D__SHORT_FILE__="\"$(subst $(SRCDIR)/,,$<)\"" -I'$(dir $<)' $(OBJEXTSINCL) $*.F90 $(FCLOGPIPE)
grid_library.o: grid_library.c $(ALL_HEADERS)
	$(CC) -c $(filter-out -DNDEBUG,$(CFLAGS)) $<
endif

# filter-out override_limits flag since IFORT can run out of memory (SIGKILL)
ifeq (1,$(INTEL))
ifneq (,$(filter -qoverride_limits,$(FCFLAGS)))
mp2_eri.o: mp2_eri.F
	$(eval MAKE_FYPP := $(if $(FYPP),$(FYPP) $(FYPPFLAGS) $< $*.F90))
	$(MAKE_FYPP)
	$(FC) -c $(filter-out -qoverride_limits,$(FCFLAGS)) -D__SHORT_FILE__="\"$(subst $(SRCDIR)/,,$<)\"" -I'$(dir $<)' $(OBJEXTSINCL) $*.F90 $(FCLOGPIPE)
minimax_exp_k53.o: minimax_exp_k53.F
	$(eval MAKE_FYPP := $(if $(FYPP),$(FYPP) $(FYPPFLAGS) $< $*.F90))
	$(MAKE_FYPP)
	$(FC) -c $(filter-out -qoverride_limits,$(FCFLAGS)) -D__SHORT_FILE__="\"$(subst $(SRCDIR)/,,$<)\"" -I'$(dir $<)' $(OBJEXTSINCL) $*.F90 $(FCLOGPIPE)
endif
mp2_optimize_ri_basis.o: mp2_optimize_ri_basis.F
	$(eval MAKE_FYPP := $(if $(FYPP),$(FYPP) $(FYPPFLAGS) $< $*.F90))
	$(MAKE_FYPP)
	$(FC) -c $(FCFLAGS) -O0 -D__SHORT_FILE__="\"$(subst $(SRCDIR)/,,$<)\"" -I'$(dir $<)' $(OBJEXTSINCL) $*.F90 $(FCLOGPIPE)
endif

ifneq (,$(filter 0,$(GNU)))
ifneq (,$(filter-out 0,$(BEEP)))
ifneq (,$(filter-out 0 1,$(INTEL)))
mp2_ri_gpw.o: mp2_ri_gpw.F
	$(eval MAKE_FYPP := $(if $(FYPP),$(FYPP) $(FYPPFLAGS) $< $*.F90))
	$(MAKE_FYPP)
	$(FC) -c $(filter-out -qopenmp,$(FCFLAGS)) -D_OPENMP -recursive -D__SHORT_FILE__="\"$(subst $(SRCDIR)/,,$<)\"" -I'$(dir $<)' $(OBJEXTSINCL) $*.F90 $(FCLOGPIPE)
pw_methods.o: pw_methods.F
	$(eval MAKE_FYPP := $(if $(FYPP),$(FYPP) $(FYPPFLAGS) $< $*.F90))
	$(MAKE_FYPP)
	$(FC) -c $(filter-out -qopenmp,$(FCFLAGS)) -D_OPENMP -recursive -D__SHORT_FILE__="\"$(subst $(SRCDIR)/,,$<)\"" -I'$(dir $<)' $(OBJEXTSINCL) $*.F90 $(FCLOGPIPE)
xc.o: xc.F
	$(eval MAKE_FYPP := $(if $(FYPP),$(FYPP) $(FYPPFLAGS) $< $*.F90))
	$(MAKE_FYPP)
	$(FC) -c $(filter-out -qopenmp,$(FCFLAGS)) -D_OPENMP -recursive -D__SHORT_FILE__="\"$(subst $(SRCDIR)/,,$<)\"" -I'$(dir $<)' $(OBJEXTSINCL) $*.F90 $(FCLOGPIPE)
endif
grid_dgemm_prepare_pab.o: grid_dgemm_prepare_pab.c $(ALL_HEADERS)
	$(CC) -c $(CFLAGS) -O$(OPT2) $<
endif
endif
